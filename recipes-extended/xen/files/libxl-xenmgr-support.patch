################################################################################
SHORT DESCRIPTION:
################################################################################

################################################################################
LONG DESCRIPTION:
################################################################################
This patch contains several changes that couldn't be grouped elsewhere. These
changes support running xl on OpenXT with xenmgr as the toplevel toolstack
component. Some of the changes include tweaking qemu options, reworking the
vfb/vkb initialization, and writing OpenXT specific xenstore nodes.  Refer
to the patch below for a comprehensive list of changes.

################################################################################
CHANGELOG
################################################################################
Authors:
################################################################################

################################################################################
LONG DESCRIPTION:
################################################################################
This patch contains several changes that couldn't be grouped elsewhere. These
changes support running xl on OpenXT with xenmgr as the toplevel toolstack
component. Some of the changes include tweaking qemu options, reworking the
vfb/vkb initialization, and writing OpenXT specific xenstore nodes.  Refer
to the patch below for a comprehensive list of changes.

################################################################################
CHANGELOG
################################################################################
Authors:
Chris Rogers <rogersc@ainfosec.com>

Updated during Xen 4.8, 4.9, 4.11 uprevs.

################################################################################
REMOVAL
################################################################################

################################################################################
UPSTREAM PLAN
################################################################################

################################################################################
INTERNAL DEPENDENCIES
################################################################################

################################################################################
PATCHES
################################################################################
diff --git a/tools/libxl/libxl.h b/tools/libxl/libxl.h
index 3b2092f7c9..b97fb8f8d8 100644
--- a/tools/libxl/libxl.h
+++ b/tools/libxl/libxl.h
@@ -1518,6 +1518,7 @@ int libxl_domain_remus_start(libxl_ctx *ctx, libxl_domain_remus_info *info,
                              const libxl_asyncop_how *ao_how)
                              LIBXL_EXTERNAL_CALLERS_ONLY;
 
+int libxl_hard_shutdown(libxl_ctx *ctx, uint32_t domid);
 int libxl_domain_shutdown(libxl_ctx *ctx, uint32_t domid);
 int libxl_domain_reboot(libxl_ctx *ctx, uint32_t domid);
 int libxl_domain_sleep(libxl_ctx *ctx, uint32_t domid);
diff --git a/tools/libxl/libxl_console.c b/tools/libxl/libxl_console.c
index b5b7de2c99..4cfca7161a 100644
--- a/tools/libxl/libxl_console.c
+++ b/tools/libxl/libxl_console.c
@@ -732,6 +732,8 @@ static int libxl__set_xenstore_vfb(libxl__gc *gc, uint32_t domid,
                                   flexarray_t *back, flexarray_t *front,
                                   flexarray_t *ro_front)
 {
+    libxl__device *device;
+
     flexarray_append_pair(back, "vnc",
                           libxl_defbool_val(vfb->vnc.enable) ? "1" : "0");
     flexarray_append_pair(back, "vnclisten", vfb->vnc.listen);
@@ -750,6 +752,13 @@ static int libxl__set_xenstore_vfb(libxl__gc *gc, uint32_t domid,
     if (vfb->sdl.display) {
         flexarray_append_pair(back, "display", vfb->sdl.display);
     }
+    GCNEW(device);
+    libxl__device_from_vfb(gc, domid, vfb, device);
+    libxl__xs_printf(gc, XBT_NULL,
+                     GCSPRINTF("%s/hotplug-status",
+                               libxl__device_backend_path(gc, device)),
+                     "connected");
+
 
     return 0;
 }
diff --git a/tools/libxl/libxl_create.c b/tools/libxl/libxl_create.c
index f6c2f33dc8..037a429b90 100644
--- a/tools/libxl/libxl_create.c
+++ b/tools/libxl/libxl_create.c
@@ -687,11 +687,30 @@ retry_transaction:
                     roperm, ARRAY_SIZE(roperm));
     libxl__xs_mknod(gc, t,
                     GCSPRINTF("%s/control", dom_path),
-                    roperm, ARRAY_SIZE(roperm));
-    if (info->type == LIBXL_DOMAIN_TYPE_HVM)
+                    rwperm, ARRAY_SIZE(rwperm));
+    libxl__xs_mknod(gc, t,
+                    GCSPRINTF("%s/error", dom_path),
+                    rwperm, ARRAY_SIZE(rwperm));
+    libxl__xs_mknod(gc, t,
+                    GCSPRINTF("%s/drivers", dom_path),
+                    rwperm, ARRAY_SIZE(rwperm));
+    libxl__xs_mknod(gc, t,
+                    GCSPRINTF("%s/attr", dom_path),
+                    rwperm, ARRAY_SIZE(rwperm));
+    libxl__xs_mknod(gc, t,
+                    GCSPRINTF("%s/data", dom_path),
+                    rwperm, ARRAY_SIZE(rwperm));
+    libxl__xs_mknod(gc, t,
+                    GCSPRINTF("%s/messages", dom_path),
+                    rwperm, ARRAY_SIZE(rwperm));
+    if (info->type == LIBXL_DOMAIN_TYPE_HVM) {
         libxl__xs_mknod(gc, t,
                         GCSPRINTF("%s/hvmloader", dom_path),
                         roperm, ARRAY_SIZE(roperm));
+        libxl__xs_printf(gc, t,
+                        GCSPRINTF("%s/hvmloader/seabios-legacy-load-roms", dom_path),
+                        "1");
+    }
 
     libxl__xs_mknod(gc, t,
                     GCSPRINTF("%s/control/shutdown", dom_path),
@@ -758,6 +777,11 @@ retry_transaction:
     libxl__xs_writev(gc, t, dom_path, info->xsdata);
     libxl__xs_writev(gc, t, GCSPRINTF("%s/platform", dom_path), info->platformdata);
 
+    if(d_config->b_info.display_depth)
+        xs_write(ctx->xsh, t, GCSPRINTF("%s/platform/restrictdisplaydepth", dom_path), "1", 1);
+    if(d_config->b_info.display_res)
+        xs_write(ctx->xsh, t, GCSPRINTF("%s/platform/restrictdisplayres", dom_path), "1", 1);
+
     xs_write(ctx->xsh, t, GCSPRINTF("%s/control/platform-feature-multiprocessor-suspend", dom_path), "1", 1);
     xs_write(ctx->xsh, t, GCSPRINTF("%s/control/platform-feature-xs_reset_watches", dom_path), "1", 1);
 
@@ -1000,6 +1024,12 @@ static void initiate_domain_create(libxl__egc *egc,
      */
     libxl_update_state(ctx, domid, "creating-devices");
 
+    /*
+     * OpenXT: XenMgr synchronizes with this state change to apply the v4v
+     * firewall rules and requires it to occur after libxl__domain_make(..).
+     */
+    libxl_update_state(ctx, domid, "creating-devices");
+
     /*
      * Set the dm version quite early so that libxl doesn't have to pass the
      * build info around just to know if the domain has a device model or not.
@@ -1415,17 +1445,12 @@ static void domcreate_launch_dm(libxl__egc *egc, libxl__multidev *multidev,
     {
         libxl__device_console console;
         libxl__device device;
-        libxl_device_vkb vkb;
 
         init_console_info(gc, &console, 0);
         console.backend_domid = state->console_domid;
         libxl__device_console_add(gc, domid, &console, state, &device);
         libxl__device_console_dispose(&console);
 
-        libxl_device_vkb_init(&vkb);
-        libxl__device_add(gc, domid, &libxl__vkb_devtype, &vkb);
-        libxl_device_vkb_dispose(&vkb);
-
         dcs->sdss.dm.guest_domid = domid;
         if (libxl_defbool_val(d_config->b_info.device_model_stubdomain))
             libxl__spawn_stub_dm(egc, &dcs->sdss);
@@ -1448,7 +1473,14 @@ static void domcreate_launch_dm(libxl__egc *egc, libxl__multidev *multidev,
         libxl__device_console console, vuart;
         libxl__device device;
 
+        fprintf(stderr, "WARNING: before adding vkb device.\n");
+        for (i = 0; i < d_config->num_vkbs; i++) {
+            fprintf(stderr, "WARNING: adding vkb device.\n");
+            libxl__device_add(gc, domid, &libxl__vkb_devtype, &d_config->vkbs[i]);
+        }
+
         for (i = 0; i < d_config->num_vfbs; i++) {
+            fprintf(stderr, "WARNING: adding vfb device.\n");
             libxl__device_add(gc, domid, &libxl__vfb_devtype,
                               &d_config->vfbs[i]);
             libxl__device_add(gc, domid, &libxl__vkb_devtype,
@@ -1462,23 +1494,17 @@ static void domcreate_launch_dm(libxl__egc *egc, libxl__multidev *multidev,
             libxl__device_console_dispose(&vuart);
         }
 
+        /* Disable QEMU for PV guests. */
+        ret = 0;
+
         init_console_info(gc, &console, 0);
         console.backend_domid = state->console_domid;
         libxl__device_console_add(gc, domid, &console, state, &device);
         libxl__device_console_dispose(&console);
 
-        ret = libxl__need_xenpv_qemu(gc, d_config);
-        if (ret < 0)
-            goto error_out;
-        if (ret) {
-            dcs->sdss.dm.guest_domid = domid;
-            libxl__spawn_local_dm(egc, &dcs->sdss.dm);
-            return;
-        } else {
-            assert(!dcs->sdss.dm.guest_domid);
-            domcreate_devmodel_started(egc, &dcs->sdss.dm, 0);
-            return;
-        }
+        assert(!dcs->sdss.dm.guest_domid);
+        domcreate_devmodel_started(egc, &dcs->sdss.dm, 0);
+        return;
     }
     default:
         ret = ERROR_INVAL;
diff --git a/tools/libxl/libxl_device.c b/tools/libxl/libxl_device.c
index ec4bf467d1..be4343c0f0 100644
--- a/tools/libxl/libxl_device.c
+++ b/tools/libxl/libxl_device.c
@@ -1993,6 +1993,12 @@ void libxl__device_add_async(libxl__egc *egc, uint32_t domid,
     aodev->action = LIBXL__DEVICE_ACTION_ADD;
     libxl__wait_device_connection(egc, aodev);
 
+    if (device->backend_kind == LIBXL__DEVICE_KIND_VIF)
+        libxl__xs_printf(gc, XBT_NULL,
+                         GCSPRINTF("%s/hotplug-status",
+                                   libxl__device_backend_path(gc, device)),
+                         "connected");
+
     rc = 0;
 
 out:
diff --git a/tools/libxl/libxl_disk.c b/tools/libxl/libxl_disk.c
index e9eceb65e3..49bfde23b2 100644
--- a/tools/libxl/libxl_disk.c
+++ b/tools/libxl/libxl_disk.c
@@ -451,6 +451,11 @@ static void device_disk_add(libxl__egc *egc, uint32_t domid,
     aodev->action = LIBXL__DEVICE_ACTION_ADD;
     libxl__wait_device_connection(egc, aodev);
 
+    libxl__xs_printf(gc, XBT_NULL,
+                     GCSPRINTF("%s/hotplug-status",
+                               libxl__device_backend_path(gc, device)),
+                     "connected");
+
     rc = 0;
 
 out:
diff --git a/tools/libxl/libxl_dm.c b/tools/libxl/libxl_dm.c
index e21ae3b235..25ee95d6ce 100644
--- a/tools/libxl/libxl_dm.c
+++ b/tools/libxl/libxl_dm.c
@@ -2113,6 +2113,20 @@ retry_transaction:
     libxl__xs_printf(gc, XBT_NULL,
                      DEVICE_MODEL_XS_PATH(gc, dm_domid, guest_domid, "/xen_extended_power_mgmt"), "2");
 
+    /* OpenXT: We wait on xenmgr writing v4v-firewall-ready.
+     *         xenmgr waits on us writing image/device-model-domid
+     */
+    int32_t timeout = 0;
+    char * ready = NULL;
+    /* Block and wait for v4v firewall rules */
+    while (timeout < 30) {
+        ready = libxl__xs_read(gc, XBT_NULL, GCSPRINTF("%s/v4v-firewall-ready", libxl__xs_get_dompath(gc, guest_domid)));
+        if(ready)
+            break;
+        sleep(1);
+        timeout++;
+    }
+
     libxl__multidev_begin(ao, &sdss->multidev);
     sdss->multidev.callback = spawn_stub_launch_dm;
     /* OpenXT: Again, no disk for the stubdom itself */
diff --git a/tools/libxl/libxl_domain.c b/tools/libxl/libxl_domain.c
index 9c1402c860..75928e2aaa 100644
--- a/tools/libxl/libxl_domain.c
+++ b/tools/libxl/libxl_domain.c
@@ -703,6 +703,13 @@ static int libxl__domain_pvcontrol(libxl__gc *gc, uint32_t domid,
     return libxl__domain_pvcontrol_write(gc, XBT_NULL, domid, cmd);
 }
 
+int libxl_hard_shutdown(libxl_ctx *ctx, uint32_t domid)
+{
+    int ret;
+    ret = xc_domain_shutdown(ctx->xch, domid, SHUTDOWN_poweroff);
+    return ret;
+}
+
 int libxl_domain_shutdown(libxl_ctx *ctx, uint32_t domid)
 {
     GC_INIT(ctx);
@@ -933,6 +940,8 @@ int libxl_domain_destroy(libxl_ctx *ctx, uint32_t domid,
     dds->ao = ao;
     dds->domid = domid;
     dds->callback = domain_destroy_cb;
+    libxl__qmp_stop(gc, dds->domid);
+    libxl__qmp_quit(gc, dds->domid);
     libxl__domain_destroy(egc, dds);
 
     return AO_INPROGRESS;
@@ -1786,7 +1795,7 @@ int libxl_retrieve_domain_configuration(libxl_ctx *ctx, uint32_t domid,
                         break;
                 }
 
-                if (j < num) {         /* found in xenstore */
+                if (j < num || !strncmp(dt->type, "nic", 4)) {         /* found in xenstore */
                     if (dt->merge)
                         dt->merge(ctx, p + dt->dev_elem_size * j, q);
                 } else {                /* not found in xenstore */
diff --git a/tools/libxl/libxl_internal.h b/tools/libxl/libxl_internal.h
index c8bfb53adc..2846f026e6 100644
--- a/tools/libxl/libxl_internal.h
+++ b/tools/libxl/libxl_internal.h
@@ -1832,6 +1832,8 @@ _hidden int libxl__qmp_pci_del(libxl__gc *gc, int domid,
                                libxl_device_pci *pcidev);
 /* Resume hvm domain */
 _hidden int libxl__qmp_system_wakeup(libxl__gc *gc, int domid);
+/* Exit QEMU */
+_hidden int libxl__qmp_quit(libxl__gc *gc, int domid);
 /* Suspend QEMU. */
 _hidden int libxl__qmp_stop(libxl__gc *gc, int domid);
 /* Resume QEMU. */
diff --git a/tools/libxl/libxl_nic.c b/tools/libxl/libxl_nic.c
index 01b711b84e..51236d83e7 100644
--- a/tools/libxl/libxl_nic.c
+++ b/tools/libxl/libxl_nic.c
@@ -129,6 +129,8 @@ static int libxl__set_xenstore_nic(libxl__gc *gc, uint32_t domid,
                                    flexarray_t *back, flexarray_t *front,
                                    flexarray_t *ro_front)
 {
+    libxl_uuid uuid;
+
     flexarray_grow(back, 2);
 
     if (nic->script)
@@ -236,6 +238,9 @@ static int libxl__set_xenstore_nic(libxl__gc *gc, uint32_t domid,
     flexarray_append(front, "mac");
     flexarray_append(front, GCSPRINTF(
                                     LIBXL_MAC_FMT, LIBXL_MAC_BYTES(nic->mac)));
+    libxl_domid_to_uuid(CTX, &uuid, nic->backend_domid);
+    flexarray_append(front, "backend-uuid");
+    flexarray_append(front, GCSPRINTF("%s", libxl__uuid2string(gc, uuid)));
 
     return 0;
 }
diff --git a/tools/libxl/libxl_qmp.c b/tools/libxl/libxl_qmp.c
index be1fda18ba..b1dd304df0 100644
--- a/tools/libxl/libxl_qmp.c
+++ b/tools/libxl/libxl_qmp.c
@@ -940,6 +940,11 @@ int libxl__qmp_system_wakeup(libxl__gc *gc, int domid)
     return qmp_run_command(gc, domid, "system_wakeup", NULL, NULL, NULL);
 }
 
+int libxl__qmp_quit(libxl__gc *gc, int domid)
+{
+    return qmp_run_command(gc, domid, "quit", NULL, NULL, NULL);
+}
+
 int libxl__qmp_save(libxl__gc *gc, int domid, const char *filename, bool live)
 {
     libxl__json_object *args = NULL;
diff --git a/tools/libxl/libxl_types.idl b/tools/libxl/libxl_types.idl
index 20cd84dde0..516d42ed00 100644
--- a/tools/libxl/libxl_types.idl
+++ b/tools/libxl/libxl_types.idl
@@ -508,6 +508,10 @@ libxl_domain_build_info = Struct("domain_build_info",[
     # device_model_user is not ready for use yet
     ("device_model_user", string),
 
+    #display restrictions
+    ("display_depth", uint32),
+    ("display_res", uint32),
+
     # extra parameters pass directly to qemu, NULL terminated
     ("extra",            libxl_string_list),
     # extra parameters pass directly to qemu for PV guest, NULL terminated
diff --git a/tools/xl/xl_misc.c b/tools/xl/xl_misc.c
index 87f4146ed7..f22256a01c 100644
--- a/tools/xl/xl_misc.c
+++ b/tools/xl/xl_misc.c
@@ -101,6 +101,51 @@ int main_uuid(int argc, char **argv)
     return 0;
 }
 
+int main_acpi(int argc, char **argv)
+{
+    int32_t domid;
+    uint32_t acpi_state;
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "domid", 1) {
+        /* No options */
+    }
+
+    domid = atoi(argv[optind]);
+
+    if (libxl_get_acpi_state(ctx, domid, &acpi_state)) {
+        fprintf(stderr, "Can't get acpi state with domid of '%d', maybe this domain does not           exist.\n", domid);
+        return 1;
+    }
+
+    printf("%d\n", acpi_state);
+
+    return 0;
+
+}
+
+int main_uuid(int argc, char **argv)
+{
+    int32_t domid;
+    int opt;
+    char *uuid = NULL;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "uuid", 1) {
+        /* No options */
+    }
+
+    uuid = argv[optind];
+
+    if (libxl_uuid_to_domid(ctx, uuid, &domid)){
+        fprintf(stderr, "Can't get domid with domain uuid of '%s', maybe this domain does not          exist.\n", uuid);
+        return 1;
+    }
+
+    printf("%d\n", domid);
+
+    return 0;
+}
+
 int main_rename(int argc, char **argv)
 {
     uint32_t domid;
diff --git a/tools/xl/xl_parse.c b/tools/xl/xl_parse.c
index 93d2fcef34..4d05f1822d 100644
--- a/tools/xl/xl_parse.c
+++ b/tools/xl/xl_parse.c
@@ -858,8 +858,9 @@ void parse_config_data(const char *config_source,
 {
     const char *buf;
     long l, vcpus = 0;
+    long vkb_flag, vfb_flag;
     XLU_Config *config;
-    XLU_ConfigList *cpus, *vbds, *nics, *pcis, *cvfbs, *cpuids, *vtpms,
+    XLU_ConfigList *cpus, *vbds, *nics, *pcis, *cpuids, *vtpms,
                    *usbctrls, *usbdevs, *p9devs, *vdispls, *pvcallsifs_devs;
     XLU_ConfigList *channels, *ioports, *irqs, *iomem, *viridian, *dtdevs,
                    *mca_caps;
@@ -1209,6 +1210,11 @@ void parse_config_data(const char *config_source,
 
     xlu_cfg_get_defbool(config, "nestedhvm", &b_info->nested_hvm, 0);
 
+    if(!xlu_cfg_get_long(config, "restrictdisplaydepth", &l, 0))
+        b_info->display_depth = l;
+    if(!xlu_cfg_get_long(config, "restrictdisplayres", &l, 0))
+        b_info->display_res = l;
+
     switch(b_info->type) {
     case LIBXL_DOMAIN_TYPE_HVM:
         kernel_basename = libxl_basename(b_info->kernel);
@@ -1836,64 +1842,38 @@ skip_nic:
         fprintf(stderr, "WARNING: vif2: netchannel2 is deprecated and not supported by xl\n");
     }
 
-    d_config->num_vfbs = 0;
-    d_config->num_vkbs = 0;
-    d_config->vfbs = NULL;
-    d_config->vkbs = NULL;
-
-    if (!xlu_cfg_get_list (config, "vfb", &cvfbs, 0, 0)) {
-        while ((buf = xlu_cfg_get_listitem (cvfbs, d_config->num_vfbs)) != NULL) {
-            libxl_device_vfb *vfb;
-            libxl_device_vkb *vkb;
-
-            char *buf2 = strdup(buf);
-            char *p, *p2;
-
-            vfb = ARRAY_EXTEND_INIT(d_config->vfbs, d_config->num_vfbs,
-                                    libxl_device_vfb_init);
-
-            vkb = ARRAY_EXTEND_INIT(d_config->vkbs, d_config->num_vkbs,
-                                    libxl_device_vkb_init);
+    //Support adding vkbs by themselves
+    if (!xlu_cfg_get_long (config, "vkb", &vkb_flag, 0)){
+        d_config->num_vkbs = 0;
+        d_config->vkbs = NULL;
+
+        if (vkb_flag == 1) {
+            for(i = 0; i < 2; i++) {
+                libxl_device_vkb *vkb;
+                fprintf(stderr, "WARNING: init vkb device\n");
+                d_config->vkbs = (libxl_device_vkb *) realloc(d_config->vkbs,                          sizeof(libxl_device_vkb) * (d_config->num_vkbs + 1));
+                vkb = d_config->vkbs + d_config->num_vkbs;
+                libxl_device_vkb_init(vkb);
+                vkb->devid = d_config->num_vkbs;
+                fprintf(stderr, "WARNING: vkb device of devid %d created.\n", vkb->devid);
+                d_config->num_vkbs++;
+            }
+        }
+    }
 
-            p = strtok(buf2, ",");
-            if (!p)
-                goto skip_vfb;
-            do {
-                while (*p == ' ')
-                    p++;
-                if ((p2 = strchr(p, '=')) == NULL)
-                    break;
-                *p2 = '\0';
-                if (!strcmp(p, "vnc")) {
-                    libxl_defbool_set(&vfb->vnc.enable, atoi(p2 + 1));
-                } else if (!strcmp(p, "vnclisten")) {
-                    free(vfb->vnc.listen);
-                    vfb->vnc.listen = strdup(p2 + 1);
-                } else if (!strcmp(p, "vncpasswd")) {
-                    free(vfb->vnc.passwd);
-                    vfb->vnc.passwd = strdup(p2 + 1);
-                } else if (!strcmp(p, "vncdisplay")) {
-                    vfb->vnc.display = atoi(p2 + 1);
-                } else if (!strcmp(p, "vncunused")) {
-                    libxl_defbool_set(&vfb->vnc.findunused, atoi(p2 + 1));
-                } else if (!strcmp(p, "keymap")) {
-                    free(vfb->keymap);
-                    vfb->keymap = strdup(p2 + 1);
-                } else if (!strcmp(p, "sdl")) {
-                    libxl_defbool_set(&vfb->sdl.enable, atoi(p2 + 1));
-                } else if (!strcmp(p, "opengl")) {
-                    libxl_defbool_set(&vfb->sdl.opengl, atoi(p2 + 1));
-                } else if (!strcmp(p, "display")) {
-                    free(vfb->sdl.display);
-                    vfb->sdl.display = strdup(p2 + 1);
-                } else if (!strcmp(p, "xauthority")) {
-                    free(vfb->sdl.xauthority);
-                    vfb->sdl.xauthority = strdup(p2 + 1);
-                }
-            } while ((p = strtok(NULL, ",")) != NULL);
+    if (!xlu_cfg_get_long (config, "vfb", &vfb_flag, 0)) {
+        d_config->num_vfbs = 0;
+        d_config->vfbs = NULL;
 
-skip_vfb:
-            free(buf2);
+        if (vfb_flag == 1) {
+            libxl_device_vfb * vfb;
+            fprintf(stderr, "WARNING: init vfb device\n");
+            d_config->vfbs = (libxl_device_vfb *) realloc(d_config->vfbs,                              sizeof(libxl_device_vfb) * (d_config->num_vfbs + 1));
+            vfb = d_config->vfbs + d_config->num_vfbs;
+            libxl_device_vfb_init(vfb);
+            vfb->devid = d_config->num_vfbs;
+            fprintf(stderr, "WARNING: vfb device of devid %d created.\n", vfb->devid);
+            d_config->num_vfbs++;
         }
     }
 
diff --git a/tools/xl/xl_vmcontrol.c b/tools/xl/xl_vmcontrol.c
index 21de24160f..845a34d273 100644
--- a/tools/xl/xl_vmcontrol.c
+++ b/tools/xl/xl_vmcontrol.c
@@ -53,7 +53,7 @@ static void destroy_domain(uint32_t domid, int force)
                         "hardware domain and toolstack.\n\n");
         exit(EXIT_FAILURE);
     }
-    
+
     rc = libxl_domid_to_uuid(ctx, &uuid, domid);
     if (rc) {
         fprintf(stderr, "domid to uuid failed during domain destroy\n");
@@ -177,7 +177,8 @@ static void hibernate_domain(uint32_t domid,
 static void shutdown_domain(uint32_t domid,
                             libxl_evgen_domain_death **deathw,
                             libxl_ev_user for_user,
-                            int fallback_trigger)
+                            int fallback_trigger,
+                            int hyper)
 {
     int rc;
 
@@ -185,7 +186,11 @@ static void shutdown_domain(uint32_t domid,
     libxl_update_state(ctx, domid, "shutdowning");
     rc=libxl_domain_shutdown(ctx, domid);
     if (rc == ERROR_NOPARAVIRT) {
-        if (fallback_trigger) {
+        if (hyper) {
+            fprintf(stderr, "PV control interface not available:"
+                    " asking for hard shutdown.\n");
+            rc = libxl_hard_shutdown(ctx, domid);
+        } else if (fallback_trigger) {
             fprintf(stderr, "PV control interface not available:"
                     " sending ACPI power button event.\n");
             rc = libxl_send_trigger(ctx, domid, LIBXL_TRIGGER_POWER, 0);
@@ -285,7 +290,7 @@ static int main_shutdown_or_reboot(int do_reboot, int argc, char **argv)
                libxl_evgen_domain_death **, libxl_ev_user, int) =
         do_reboot ? &reboot_domain : &shutdown_domain;
     int opt, i, nb_domain;
-    int wait_for_it = 0, all = 0, nrdeathws = 0;
+    int wait_for_it = 0, all = 0, nrdeathws = 0, hyper = 0;
     int fallback_trigger = 0;
     static struct option opts[] = {
         {"all", 0, 0, 'a'},
@@ -293,7 +298,7 @@ static int main_shutdown_or_reboot(int do_reboot, int argc, char **argv)
         COMMON_LONG_OPTS
     };
 
-    SWITCH_FOREACH_OPT(opt, "awF", opts, what, 0) {
+    SWITCH_FOREACH_OPT(opt, "awFc", opts, what, 0) {
     case 'a':
         all = 1;
         break;
@@ -303,6 +308,9 @@ static int main_shutdown_or_reboot(int do_reboot, int argc, char **argv)
     case 'F':
         fallback_trigger = 1;
         break;
+    case 'c':
+        hyper = 1;
+        break;
     }
 
     if (!argv[optind] && !all) {
@@ -325,7 +333,7 @@ static int main_shutdown_or_reboot(int do_reboot, int argc, char **argv)
             if (dominfo[i].domid == 0 || dominfo[i].never_stop)
                 continue;
             fn(dominfo[i].domid, deathws ? &deathws[i] : NULL, i,
-               fallback_trigger);
+               fallback_trigger, hyper);
             nrdeathws++;
         }
 
@@ -339,7 +347,7 @@ static int main_shutdown_or_reboot(int do_reboot, int argc, char **argv)
         libxl_evgen_domain_death *deathw = NULL;
         uint32_t domid = find_domain(argv[optind]);
 
-        fn(domid, wait_for_it ? &deathw : NULL, 0, fallback_trigger);
+        fn(domid, wait_for_it ? &deathw : NULL, 0, fallback_trigger, hyper);
 
         if (wait_for_it)
             wait_for_domain_deaths(&deathw, 1);
@@ -769,8 +777,10 @@ int create_domain(struct domain_create *dom_info)
     int notify_pipe[2] = { -1, -1 };
     struct save_file_header hdr;
     uint32_t domid_soft_reset = INVALID_DOMID;
+    int restoring;
 
-    int restoring = (restore_file || (migrate_fd >= 0));
+start:
+     (restore_file || (migrate_fd >= 0));
 
     libxl_domain_config_init(&d_config);
 
@@ -967,7 +977,6 @@ int create_domain(struct domain_create *dom_info)
     if (dom_info->dryrun)
         goto out;
 
-start:
     assert(domid == INVALID_DOMID);
 
     rc = acquire_lock();
@@ -1161,8 +1170,6 @@ start:
                  */
                 dom_info->console_autoconnect = 0;
 
-                /* Some settings only make sense on first boot. */
-                paused = 0;
                 if (common_domname
                     && strcmp(d_config.c_info.name, common_domname)) {
                     d_config.c_info.name = strdup(common_domname);
